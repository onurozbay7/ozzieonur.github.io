<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Yazılım Mimarisi</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"
    />
    <link rel="stylesheet" href="styles.css" />
    <script src="https://kit.fontawesome.com/68bb1f19e7.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <nav>
      <div class="container">
        <div class="navLogo">
          <a href="">
            <h1>OnurOzbay.me</h1>
          </a>
        </div>

        <div class="navLink">
          <ul>
            <li>
              <a target="_blank"  href="https://www.linkedin.com/in/onurozbay/"
                ><i class="fa fa-linkedin-square" aria-hidden="true"></i
              ></a>
            </li>
            <li>
              <a target="_blank"  href="https://github.com/ozzieonur"> <i class="fa fa-github" aria-hidden="true"></i></a>
            </li>
          </ul>
        </div>

      </div>
    </nav>

    <section class="firstSection">
      <div class="container">
        <h2 class="mainTitle">YAZILIM MİMARİSİ</h2>
        <div class="content">
          <img src="assets/img/software_arch.png" alt="" />
          <p class="generalText text1">
            Bir bina yapılmaya başlamadan önce mimarlar tarafından projenin ön çizimi, tasarımı çizilir. Tıpkı bunun gibi bir yazılım projesinin de yapılmaya başlamadan önce planlanması gerekir. Bu planlamaya “Yazılım Mimarisi” bu planı tasarlayan kişilere de “Yazılım Mimarı” denir. Mimari, yazılım uygulamasının bir donanımın, ağların ve bir işletmenin diğer bileşenleriyle nasıl etkileşime gireceğini ana hatlarıyla anlatan eksiksiz bir tasarım belgeleri seti içerir. Böylelikle yazılım geliştiricilerin izleyeceği yol genel hatları ile belirlenmiş olur. <br />
            <br />
            Genellikle yalnızca kullandığınız bulut hizmetleri için ödeme
            yaparsınız, bu da işletim maliyetlerinizi düşürmenize, altyapınızı
            daha verimli çalıştırmanıza ve iş ihtiyaçlarınız değiştikçe
            ölçeklendirmenize yardımcı olur.
          </p>
        </div>
        <br /><br /><br /><br />
        <h1 class="mainTitle">NEDEN YAZILIM MİMARİSİNE İHTİYAÇ DUYARIZ?</h1>
        <div class="content">
          <p class="generalText">
            Yazılım geliştirme süreci karmaşık bir süreçtir. Bu süreçte dağılmak istemiyorsanız bir yazılım mimarisi oluşturmalısınız. Yazılım mimarisine ihtiyaç duymamızın en önemli sebeplerinden biri de sistemin karmaşıklığını yönetmek ve bütünlüğünü korumak için pratik bir yapı sunmasıdır. Bunun yanı sıra son derece iyi hazırlanmış bir mimarisi olmadan, yazılan sistem üzerine gelecek yeni yazılımları ve teknolojileri kabul etmez. Kullanımı ve uygulanabilirliği kolay sağlam sistemler yaratmak için ihtiyacınız olanların başında yazılım mimarisi gelir. Bir de ek olarak, olaya temel açıdan bakarsak yazılımları 2 parçaya ayırabiliriz. Bunların ilki Graphical User Interface (GUI) yani kullanıcıların gördüğü ve kullandığı görünüm ara yüzüdür. İkincisi ise bu ara yüzün kontrol mekanizması ve planlayıcısı olan bir mantık ünitesidir. Yazılımda mimarisi de tam olarak bu iki kısmın birbirinden etkilenmemesi için görünüm ara yüzünü, mantık ünitesinden ayırmaya yarar.
          </p>
        </div>
      </div>
    </section>

    <section class="fourthSection">
        <div class="container">
            <h2 class="mainTitle">Yazılım Mimarisinde Olması Gereken Özellikler</h2>
            <div class="cards">
                <div class="card">
                    <h2 class="subTitle">İşlevsellik</h2>
                    <p class="generalText">  Yazılımın kullanım amacına göre performans düzeyini ifade eder.</p>
                </div>
                <div class="card">
                    <h2 class="subTitle">Güvenilirlik</h2>
                    <p class="generalText">   Ürünün verilen koşullar altında istenilen işlevselliği sunabilme kabiliyetini ifade eder.</p>
                </div>
                <div class="card">
                    <h2 class="subTitle">Kullanılabilirlik</h2>
                    <p class="generalText">  Yazılım ürününün ne ölçüde kolaylıkla kullanılabileceğini ifade eder.</p>
                </div>
                <div class="card">
                    <h2 class="subTitle">Performans</h2>
                    <p class="generalText">   İşlem hızı, yanıt süresi, kaynak kullanımı, çıktı ve üretkenlik dikkate alınarak yapılan tahmini ifade eder.</p>
                </div>
                <div class="card">
                    <h2 class="subTitle">Desteklenebilirlik</h2>
                    <p class="generalText">   Programlama geliştiricilerinin yazılımı bir platformdan diğerine herhangi bir değişiklik yapmadan veya minimum değişiklikle aktarabilme kolaylığı anlamına gelir.</p>
                </div>
                <div class="card">
                    <h2 class="subTitle">Kendine Güven</h2>
                    <p class="generalText">   Bağımsız servislerden birinin kesintiye uğramasına rağmen optimum performans gösterme yeteneğini ifade eder.</p>
                </div>


            </div>
        </div>
    </section>

    <section class="secondSection">
      <div class="container">
        <h2 class="mainTitle">YAZILIM MİMARİSİ İLKELERİ</h2>
        <div class="content">
          <p class="generalText">
            Yazılım mimarisini yukarıda bahsedilen özelliklere sahip olması ve başarılı bir mimari tasarım olması için Yazılım Mimarisi İlkeleri ‘ne (S.O.L.I.D Principles) bağlı kalmalıdır.
          </p>
          <img src="assets/img/solid.png" alt="" />
        <div class="cards">
          <div class="bigcard">
              <h2 class="subTitle">Tek Sorumluluk İlkesi (Single Responsibility Principle)</h2>
              <p class="generalText">   Her sistem yeteneğinin (örneğin hizmet/modül/api) yalnızca bir sorumluluğu ve dolayısıyla bir değişiklik nedeni olmalıdır. Sorumlulukları mümkün olduğunca dar tutmak, kullanıcıların amaçlanan amacı bilmesi anlamına gelir ve bu da daha az hataya yol açar.</p>
          </div>

          <div class="bigcard">
              <h2 class="subTitle">Açık-Kapalı İlkesi (Open-Closed Principle)</h2>
              <p class="generalText">  Bu ilke, bir sistem davranışını değiştirmeden genişletmenin tercih edilebileceğini varsayar. Gereksinimlerdeki değişiklikleri önceden tahmin etmeye çalışmak çoğu zaman iyi bir fikir olmasa da (aşırı karmaşık tasarımlara yol açabileceğinden), yeni işlevleri mevcut bileşenlerde minimum değişiklikle uyarlayabilmek, uygulamanın uzun ömürlü olmasının anahtarıdır.</p>
          </div>

          <div class="bigcard">
              <h2 class="subTitle">Liskov İkame İlkesi (Liskov Substitution Principle)</h2>
              <p class="generalText">   Herhangi iki bağımsız hizmet, gerektiğinde bir API çağrısı aracılığıyla birbirleriyle iletişim kurabilmelidir. Ayrıca, aynı sözleşmeye sahip iki hizmet, genel sistemi değiştirmeden birbirleri arasında ikame olarak hareket edebilmelidir.</p>
          </div>

          <div class="bigcard">
              <h2 class="subTitle">Arayüz Ayrıştırma İlkesi (Interface Segregation Principle)</h2>
              <p class="generalText">   Arayüzler/sözleşmeler mümkün olduğunca ayrıntılı ve müşteriye özel olmalıdır, bu nedenle çağrı yapan istemciler, kullanmadıkları işlevselliğe bağlı değildir. Bu, Tek Sorumluluk ilkesiyle el ele gider: arayüzleri parçalayarak, rollere/sorumluluklara göre ayırarak Kompozisyon'u ve türev modülleri gereksiz sorumluluklarla birleştirmeyerek Dekuplaj'ı tercih ederiz.</p>
          </div>

          <div class="bigcard">
              <h2 class="subTitle">Bağımlılık Tersine Çevirme İlkesi (Dependency Inversion Principle)</h2>
              <p class="generalText">   Yüksek seviyeli modüller, düşük seviyeli modüllere bağlı olmamalıdır; her ikisi de soyutlamalara dayanmalıdır. Aynı şekilde, soyutlamalar ayrıntılara bağlı olmamalıdır, ancak ayrıntılar soyutlamalara bağlı olmalıdır. Bu ilke, aralarındaki bağımlılıkları ortadan kaldırmak için üst düzey ve alt düzey yazılım bileşenleri veya katmanları arasında bir arabirim soyutlaması sunar.</p>
          </div>



        </div>
        </div>
      </div>
    </section>

    <section class="thirdSection">
      <div class="container">
        <h2 class="mainTitle">Yazılım Mimarisinde Kullanılan Şablonlar</h2>
        <img src="assets/img/MVC.jpg" alt="" />
        <p class="generalText">
          Model-View-Controller (MVC) en çok bilinen ve sık sık kullanılan şablondur. Yani bir anlamda bunun için default ve her türlü yazılım tipi için uygundur diyebiliriz. Pipe and Filter şablonu ise genelde complier için kullanılır ve nu mimari şablonun amacı yapılacak işlemi parçalara ayırmaktır. Son yıllarda yazılım alanının en çok tercih edilen şablonu olan Service-Oriented-Architecture (SOA) ise temel olarak sistem üzerinde birçok sistemin uyumlu şekilde çalışmasını amaçlar. Bunların dışında Multitier Architecture (Çok Katmanlı Mimari) ve Implict Invocation gibi daha kapsamlı ve nispeten daha az tercih edilen yazılım mimarisi şablonları da mevcuttur.
          <br> <br>
          Bir yazılım projesini hayata geçirebilmek için yazılım mimarisinin son derece dikkatli ve kapsamlı bir şekilde hazırlanmış olması gereklidir. Bu, büyük çaplı ve hata riski kabul etmeyen projeler için daha da önem taşır.
        </p>
          <img src="assets/img/soa.png" alt="" />

    </section>



  </body>
</html>
